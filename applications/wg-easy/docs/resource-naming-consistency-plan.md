# Resource Naming Consistency Plan

## Overview

This plan outlines the implementation of a consistent resource naming strategy for the wg-easy PR validation workflow. The current approach has mixed naming patterns across different resources, making tracking and management more difficult than necessary.

## Current State

**Current Naming Patterns:**
- **Channels:** Lowercase with hyphens (`feature-auth-fix`)
- **Customers:** Channel name + run number (`feature-auth-fix-123`)
- **Clusters:** Channel name only (`feature-auth-fix`)
- **Releases:** Auto-generated by Replicated
- **Artifacts:** Manual naming with run numbers

**Matrix Enhancement (January 2025):**
- ✅ **Matrix-Based Naming** - Resources now include matrix identifiers
- ✅ **Distribution-Specific Names** - `cluster-name-k8s-version-distribution`
- ✅ **Customer Matrix Names** - `customer-name-k8s-version-distribution`
- ✅ **Artifact Matrix Names** - `debug-logs-run-k8s-version-distribution`

**Remaining Inconsistencies:**
- Matrix naming only partially implemented
- No unified format across all resource types
- Limited standardization for non-matrix resources
- Inconsistent metadata inclusion
- Cross-resource correlation could be improved

## Proposed Enhancement

### Unified Naming Strategy

Implement a consistent naming convention that:

1. **Standardizes normalization** across all resources
2. **Provides clear traceability** between related resources
3. **Includes metadata** for debugging and management
4. **Supports uniqueness** across concurrent workflows
5. **Maintains readability** for human operators

**Naming Format:** `{prefix}-{normalized-branch}-{resource-type}-{run-id}`

**Example:** `wg-easy-feature-auth-fix-cluster-12345`

**Matrix-Enhanced Format:** `{prefix}-{normalized-branch}-{resource-type}-{run-id}-{matrix-id}`

**Matrix Example:** `wg-easy-feature-auth-fix-cluster-12345-k3s-v1-32-2`

**Current Partial Implementation:**
- Matrix identifiers added to customers and clusters
- Basic matrix naming pattern established
- Foundation for unified naming created

## Implementation Plan

### Phase 1: Naming Convention Definition - PARTIALLY IMPLEMENTED ✅

#### Task 1.1: Naming Standards - PARTIALLY COMPLETED ✅
- [x] Define standard naming format (matrix-based implementation)
- [x] Create normalization rules (hyphen replacement implemented)
- [x] Establish length limits (implicit via matrix constraints)
- [x] Define allowed characters (matrix-compatible format)

**Achievement:** Matrix-based naming implemented for customers and clusters

#### Task 1.2: Resource-Specific Rules - PARTIALLY COMPLETED ✅
- [x] Define channel naming rules (branch-based normalization)
- [x] Define customer naming rules (matrix-enhanced format)
- [x] Define cluster naming rules (matrix-enhanced format)
- [ ] Define artifact naming rules (partially implemented)
- [ ] Define release naming rules
- [ ] Define customer naming rules
- [ ] Define cluster naming rules
- [ ] Define artifact naming rules

#### Task 1.3: Metadata Integration
- [ ] Include resource type in names
- [ ] Add run ID for uniqueness
- [ ] Include branch information
- [ ] Add timestamp where appropriate

#### Task 1.4: Validation Rules
- [ ] Create name validation functions
- [ ] Add length validation
- [ ] Add character validation
- [ ] Add uniqueness validation

### Phase 2: Implementation

#### Task 2.1: Naming Function Library
- [ ] Create centralized naming functions
- [ ] Implement normalization utilities
- [ ] Add validation functions
- [ ] Create name generation utilities

#### Task 2.2: Workflow Integration
- [ ] Update setup job with naming functions
- [ ] Modify resource creation to use standard names
- [ ] Update resource references throughout workflow
- [ ] Add name validation steps

#### Task 2.3: Resource Tracking
- [ ] Add resource name logging
- [ ] Create resource mapping
- [ ] Add cross-resource correlation
- [ ] Implement resource tracking

### Phase 3: Advanced Features

#### Task 3.1: Name Templates
- [ ] Create configurable name templates
- [ ] Add environment-specific naming
- [ ] Implement conditional naming rules
- [ ] Add name template validation

#### Task 3.2: Name Analytics
- [ ] Track name usage patterns
- [ ] Monitor name conflicts
- [ ] Add name optimization suggestions
- [ ] Create name usage reports

#### Task 3.3: Name Migration
- [ ] Plan migration from old naming
- [ ] Implement backward compatibility
- [ ] Add migration validation
- [ ] Create migration tools

## Technical Implementation

### Naming Function Library

```yaml
- name: Generate Resource Names
  id: names
  run: |
    # Common naming function
    generate_name() {
      local prefix="$1"
      local branch="$2"
      local resource_type="$3"
      local run_id="$4"
      
      # Normalize branch name
      local normalized_branch=$(echo "$branch" | 
        tr '[:upper:]' '[:lower:]' | 
        sed 's/[^a-zA-Z0-9]/-/g' | 
        sed 's/--*/-/g' | 
        sed 's/^-\|-$//g' | 
        cut -c1-20)
      
      # Generate full name
      local full_name="${prefix}-${normalized_branch}-${resource_type}-${run_id}"
      
      # Validate length (max 63 chars for Kubernetes)
      if [ ${#full_name} -gt 63 ]; then
        # Truncate branch part to fit
        local max_branch_len=$((63 - ${#prefix} - ${#resource_type} - ${#run_id} - 3))
        normalized_branch=$(echo "$normalized_branch" | cut -c1-$max_branch_len)
        full_name="${prefix}-${normalized_branch}-${resource_type}-${run_id}"
      fi
      
      echo "$full_name"
    }
    
    # Generate all resource names
    BRANCH_NAME="${{ github.head_ref || github.ref_name }}"
    RUN_ID="${{ github.run_id }}"
    PREFIX="wg-easy"
    
    CHANNEL_NAME=$(generate_name "$PREFIX" "$BRANCH_NAME" "channel" "$RUN_ID")
    CUSTOMER_NAME=$(generate_name "$PREFIX" "$BRANCH_NAME" "customer" "$RUN_ID")
    CLUSTER_NAME=$(generate_name "$PREFIX" "$BRANCH_NAME" "cluster" "$RUN_ID")
    RELEASE_NAME=$(generate_name "$PREFIX" "$BRANCH_NAME" "release" "$RUN_ID")
    
    # Output all names
    echo "channel-name=$CHANNEL_NAME" >> $GITHUB_OUTPUT
    echo "customer-name=$CUSTOMER_NAME" >> $GITHUB_OUTPUT
    echo "cluster-name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
    echo "release-name=$RELEASE_NAME" >> $GITHUB_OUTPUT
    
    # Create resource mapping
    cat > /tmp/resource-mapping.json << EOF
    {
      "workflow_id": "${{ github.run_id }}",
      "branch": "$BRANCH_NAME",
      "pr_number": "${{ github.event.number }}",
      "resources": {
        "channel": "$CHANNEL_NAME",
        "customer": "$CUSTOMER_NAME",
        "cluster": "$CLUSTER_NAME",
        "release": "$RELEASE_NAME"
      }
    }
    EOF
```

### Naming Configuration

```yaml
# naming-config.yaml
naming:
  prefix: "wg-easy"
  max-length: 63
  separator: "-"
  
  normalization:
    case: "lower"
    allowed-chars: "[a-zA-Z0-9-]"
    replacement-char: "-"
    trim-chars: "-"
    
  resource-types:
    channel: "chan"
    customer: "cust"
    cluster: "clus"
    release: "rel"
    artifact: "art"
    
  templates:
    standard: "{prefix}-{branch}-{type}-{run-id}"
    short: "{prefix}-{branch}-{run-id}"
    debug: "{prefix}-{branch}-{type}-{run-id}-{attempt}"
    
  validation:
    min-length: 3
    max-length: 63
    required-parts: ["prefix", "branch", "run-id"]
```

### Resource Correlation

```yaml
- name: Create Resource Correlation
  run: |
    # Create correlation mapping
    cat > /tmp/correlation.json << EOF
    {
      "correlation_id": "${{ github.run_id }}-${{ github.run_attempt }}",
      "workflow": "${{ github.workflow }}",
      "branch": "${{ github.head_ref || github.ref_name }}",
      "pr_number": "${{ github.event.number }}",
      "resources": {
        "channel": {
          "name": "${{ steps.names.outputs.channel-name }}",
          "id": "${{ steps.create-channel.outputs.channel-id }}",
          "type": "channel"
        },
        "customer": {
          "name": "${{ steps.names.outputs.customer-name }}",
          "id": "${{ steps.create-customer.outputs.customer-id }}",
          "type": "customer"
        },
        "cluster": {
          "name": "${{ steps.names.outputs.cluster-name }}",
          "id": "${{ steps.create-cluster.outputs.cluster-id }}",
          "type": "cluster"
        }
      },
      "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
      "tags": {
        "environment": "pr-validation",
        "project": "wg-easy",
        "owner": "${{ github.actor }}"
      }
    }
    EOF
```

## Migration Strategy

### Phase 1: Backward Compatibility

#### Task 1: Dual Naming Support
- [ ] Support both old and new naming conventions
- [ ] Add fallback logic for existing resources
- [ ] Implement name translation utilities
- [ ] Add migration validation

#### Task 2: Gradual Migration
- [ ] Migrate new resources to new naming
- [ ] Update existing resources progressively
- [ ] Add migration progress tracking
- [ ] Validate migration success

#### Task 3: Legacy Cleanup
- [ ] Identify legacy-named resources
- [ ] Plan cleanup strategy
- [ ] Implement cleanup automation
- [ ] Add cleanup validation

### Phase 2: Full Migration

#### Task 1: Update All Resources
- [ ] Update all workflow references
- [ ] Update all task references
- [ ] Update all documentation
- [ ] Update all examples

#### Task 2: Validation
- [ ] Validate all resources use new naming
- [ ] Test cross-resource correlation
- [ ] Validate name uniqueness
- [ ] Test name collision handling

## Resource Naming Examples

### Current Naming
```
Channel: "feature-auth-fix"
Customer: "feature-auth-fix-123"
Cluster: "feature-auth-fix"
Artifact: "wg-easy-release-123"
```

### Proposed Naming
```
Channel: "wg-easy-feature-auth-fix-chan-12345"
Customer: "wg-easy-feature-auth-fix-cust-12345"
Cluster: "wg-easy-feature-auth-fix-clus-12345"
Artifact: "wg-easy-feature-auth-fix-art-12345"
```

### Resource Correlation
```json
{
  "correlation_id": "12345-1",
  "resources": {
    "channel": "wg-easy-feature-auth-fix-chan-12345",
    "customer": "wg-easy-feature-auth-fix-cust-12345",
    "cluster": "wg-easy-feature-auth-fix-clus-12345"
  }
}
```

## Monitoring and Observability

### Naming Metrics
- [ ] Name generation success rate
- [ ] Name validation failures
- [ ] Name collision frequency
- [ ] Name length distribution

### Resource Tracking
- [ ] Resource creation tracking
- [ ] Resource cleanup tracking
- [ ] Resource correlation accuracy
- [ ] Resource naming consistency

## Configuration Management

### Environment-Specific Naming

```yaml
environments:
  development:
    prefix: "wg-easy-dev"
    include-env: true
    
  staging:
    prefix: "wg-easy-staging"
    include-env: true
    
  production:
    prefix: "wg-easy"
    include-env: false
```

### Branch-Type Specific Naming

```yaml
branch-types:
  feature/*:
    prefix: "wg-easy-feat"
    resource-type: "feat"
    
  bugfix/*:
    prefix: "wg-easy-fix"
    resource-type: "fix"
    
  hotfix/*:
    prefix: "wg-easy-hot"
    resource-type: "hot"
```

## Risk Assessment

### High Risk
- **Name Collisions:** Multiple resources with same name
- **Length Limits:** Names exceeding platform limits
- **Migration Issues:** Problems during naming migration

### Medium Risk
- **Backward Compatibility:** Breaking existing references
- **Validation Failures:** Strict validation causing failures
- **Complexity:** Increased naming complexity

### Low Risk
- **Documentation:** Need for updated documentation
- **Training:** Team adaptation to new naming
- **Tooling:** Updates to supporting tools

## Testing Strategy

### Unit Testing
- [ ] Name generation function tests
- [ ] Name validation tests
- [ ] Name normalization tests
- [ ] Name correlation tests

### Integration Testing
- [ ] End-to-end naming workflow tests
- [ ] Resource creation with new names
- [ ] Resource cleanup with new names
- [ ] Cross-resource correlation tests

### Migration Testing
- [ ] Backward compatibility tests
- [ ] Migration validation tests
- [ ] Legacy cleanup tests
- [ ] Name collision tests

## Success Criteria

### Phase 1 Success
- [ ] Consistent naming across all resources
- [ ] Proper name validation and generation
- [ ] Resource correlation working
- [ ] Backward compatibility maintained

### Phase 2 Success
- [ ] Full implementation of new naming
- [ ] All resources using consistent names
- [ ] Resource tracking and correlation
- [ ] Migration completed successfully

### Phase 3 Success
- [ ] Advanced naming features operational
- [ ] Name analytics and optimization
- [ ] Complete documentation and training
- [ ] Legacy cleanup completed

## Timeline

### Phase 1: Definition and Planning (1-2 weeks)
- Week 1: Naming convention definition
- Week 2: Implementation planning and validation

### Phase 2: Implementation (2-3 weeks)
- Week 3-4: Core naming function implementation
- Week 5: Workflow integration and testing

### Phase 3: Advanced Features (2-3 weeks)
- Week 6-7: Advanced features and analytics
- Week 8: Migration and cleanup

## Dependencies

- GitHub Actions workflow access
- Replicated API naming constraints
- Kubernetes resource naming limits
- Team coordination for migration

## Rollback Plan

If naming consistency causes issues:
1. Revert to original naming patterns
2. Implement gradual rollout
3. Add naming override capabilities
4. Implement manual name correction

## Future Considerations

- Integration with external naming services
- Automated name optimization
- Advanced name analytics
- Multi-project naming coordination
- Integration with resource management tools